- 先考虑边界情况，如if not obj

- 对于动态规划问题，先确定状态，想象一个状态数组，写出状态方程，再分析边界情况

- 用数据结构解决，比如栈，双栈，堆，队列等

- dfs和bfs
  - dfs主要用递归，或者暴力for来代替dfs
  - bfs主要用队列，while迭代

- 对于python的大数越界问题，虽然python的大数可以不考虑，但若要考虑可以考虑转换成字符串问题

- lc问题种类：
  - 大数越界问题
    - 转换成字符串
    - 分治
  - 路径问题
    - dfs
    - bfs
  - ListNode问题
    - 双指针
      - pre和cur经常要在while之前先定义
      - 双指针问题一般涉及迭代和递归
    - 三指针
      - 三指针问题一般能转化为双指针
    - 链表的reference问题，用来保存整体，可以在while改变链表结构之前先把整个链表（头节点）赋值给一个reference
    - 链表问题的边界情况
      - 链表是否为空
      - 若有多个链表，链表等长问题（三元表达式）
  - 动态规划问题
    - 对于动态规划问题，先确定状态，想象一个状态数组，写出状态方程，再分析边界情况
  - 递归问题
    - 递归问题分为递和归两个部分。有三个要素。递归结束条件，递归等价关系式子，递归出口。
    - 在设计和理解递归的时候，可以把递归过程想象成一个递归栈stack，每次递归都是将这行程序入栈，遇到边界条件返回后依次弹出。
    - skelton code:
      - ```python
         def recur():
            if case: return res  # 边界条件
            return recur() + operation  # recur()是递，+operation是归
        ```
      - 要考虑返回值。比如，若返回的是一个最终的递归结果，那么return后直接写递归公式；如果返回的是一个整体，递归过程只是对整体修改，那么需要把递归公式赋值，然后修改函数内部，比如res = recur()，这个是递归等价式子，然后return句是递归出口。
      - 写完递归问题要仔细考虑是否能精简代码优化设计，代码风格很重要。
  - 二叉树匹配问题
    - 比如匹配两个子树，比如匹配子树。
    - 一般用递归来做，可能涉及多个递归。
    - 先将根节点匹配；根节点匹配后，对子树进行匹配。 

- 遇到while问题，若很难放进一个while，可以先用for遍历到我们需要的地方再开始while，结合for和while一起使用。

- 对于listnode的while问题，注意while的条件，若while是head的时候，那么当指针直到最后一个节点的next，即None的时候，才不循环。